//*********************************************************************************
//
//	Copyright (c) 2017-2022, INTO-CPS Association,
//	c/o Professor Peter Gorm Larsen, Department of Engineering
//	Finlandsgade 22, 8200 Aarhus N.
//
//	MIT Licence:
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy of
//	this software and associated documentation files (the "Software"), to deal in
//	the Software without restriction, including without limitation the rights to use,
//	copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
//	Software, and to permit persons to whom the Software is furnished to do so,
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
//	PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//	SPDX-License-Identifier: MIT
//
//********************************************************************************/

=== Introduction

This Network Communication Standard contains a complete description of how to define network signals as input and output variables within an FMU.

This appendix defines formal rules that clarify the textual description in the Standard. The formal rules can be used to automatically test the compliance of an FMU with the Standard. Each rule contains links to places in the Standard where the rule is relevant. Similarly, links in the Standard refer to the rules given in this appendix.

The rules only cover the _static_ semantics of the Standard. That is, they describe the rules for correctly configured XML files, not the subsequent _dynamic_ behaviour of the FMUs.

=== VDM-SL Specifications

The rules are defined in VDM-SL, the specification language of the https://en.wikipedia.org/wiki/Vienna_Development_Method[Vienna Development Method].  The language has a formal semantics, enabling proof of the properties of models to a high level of assurance. It also has an executable subset, so that real world data can be processed.

Free https://github.com/overturetool/vdm-vscode[open source tools] are available to process the VDM-SL rules, and https://github.com/INTO-CPS-Association/FMI-VDM-Model/releases[check FMUs for compliance].

=== The VDM-SL Network Description type

In order to define rules for a correctly configured XML files, the various formats of the <<NetworkDescriptionFile>> must be represented as a common VDM-SL record type. This type is an abstract representation of the aspects of the real network description that matter to the rules.

----
types
	Name = seq1 of char
	NetworkDescription = set1 of Bus;

	Bus ::
		name	: Name
		frames	: set1 of Frame;

	Frame ::
		name	: Name
		pdus	: set1 of PDU;

	PDU ::
		name	: Name
		signals	: set1 of Signal;

	Signal ::
		name	: Name
		unit	: [Unit];
----

=== Rules

// This adds the "functions" section header for VDM
ifdef::hidden[]
// {vdm}
functions
// {vdm}
endif::[]

==== Rule 2.3.1a [[rule_2.3.1a]]
Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminal,frame terminals>>. The attribute `name` of the `<Terminal>` must match the root name of its <<NetworkDescriptionFile>>.
// {vdm}
----
rule_231a: NetworkDescription * FmiTerminalsAndIcons +> bool
rule_231a(nd, ti) == allOf
([
	-- @OnFail("Missing 'bus' Terminal for %s", bus.name)
	( exists terminal in seq ti.terminals & terminal.name = bus.name )

	| bus in seq nd
]);
----
// {vdm}
See [<<apply_2.3.1a, Bus terminal>>] _[In general, this can be a list of places where the rule is relevant]_

==== Rule 2.3.1b [[rule_2.3.1b]]
A bus terminal `terminalKind` must be set to `bus`, the `matchingRule` must be set to `bus` and the `name` is the network name, e.g. `Powertrain`.
// {vdm}
----
rule_231b: Bus * Terminal +> bool
rule_231b(busDescription, busTerminal) == allOf
([
	-- @OnFail("Bus terminal must be terminalKind 'bus' at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminalKind = "bus" ),

	-- @OnFail("Bus temrinal must have matchingRule 'bus' at %s")
	-- loc2str(busTerminal.location))
	( busTerminal.matchingRule = "bus" ),

	-- @OnFail("Bus %s does not match network description name %s at %s",
	-- busTerminal.name, busDescription.name, loc2str(busTerminal.location))
	( busTerminal.name = busDescription.name ),

	-- @OnFail("Bus has wrong number of frames at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminal <> nil
		and len busTerminal.terminal = len busDescription.frames )
]);
----
// {vdm}
See [<<apply_2.3.1b, Bus attributes>>]

==== Rule 2.3.1c [[rule_2.3.1c]]
If frame variables (`BusName::FRAMES_in` and `BusName::FRAMES_out`) and their clocks (`BusName::FRAMES_in_CLOCK` and `BusName::FRAMES_out_CLOCK`) are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here. There must be no `<TerminalStreamMemberVariable>` element.
// {vdm}
----
rule_231c: Bus * FmiModelDescription * Terminal +> bool
rule_231c(busDescription, modelDescription, busTerminal) == allOf
([
	let variableName = busDescription.name ^ "::" ^ varName in
		-- @OnFail("Missing TerminalMemberVariable for %s", variableName)
		( lookup(modelDescription, variableName) <> nil =>
			exists tmv in seq busTerminal.terminalMemberVariable &
				tmv.variableName = variableName )

	| varName in seq
		[ "FRAMES_in", "FRAMES_out", "FRAMES_in_CLOCK", "FRAMES_out_CLOCK" ]
]
^
[
	-- @OnFail("TerminalStreamMemberVariables must be empty at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminalStreamMemberVariable = nil )
]);
----
// {vdm}
See [<<apply_2.3.1c, Bus elements>>]

==== Rule 2.3.2a [[rule_2.3.2a]]
_[Explanation here]_.

// {vdm}
----
rule_232a: Bus * Terminal +> bool
rule_232a(busDesc, busTerminal) == allOf
([
	-- @OnFail("Missing 'frame' Terminal for %s", frame.name)
	( exists f in seq busTerminal.terminal & f.name = frame.name )

	| frame in seq busDesc.frames
]);
----
// {vdm}
See [<<apply_2.3.2a, Frame terminal>>]

==== Rule 2.3.2b [[rule_2.3.2b]]
_[Explanation here]_.

// {vdm}
----
rule_232b: Frame * Terminal +> bool
rule_232b(frameDesc, frameTerminal) == allOf
([
	-- @OnFail("Frame terminal must be terminalKind 'frame' at %s",
	-- loc2str(frameTerminal.location))
	( frameTerminal.terminalKind = "frame" ),

	-- @OnFail("Frame temrinal must have matchingRule 'bus' at %s")
	-- loc2str(busTerminal.location))
	( frameTerminal.matchingRule = "bus" ),

	-- @OnFail("Frame %s does not match network description name %s at %s",
	-- frameTerminal.name, frameDesc.name, loc2str(frameTerminal.location))
	( frameTerminal.name = frameDesc.name )
]);
----
// {vdm}
See [<<apply_2.3.2b, Frame attributes>>]

==== Rule 2.3.2c [[rule_2.3.2c]]
_[Explanation here]_.

// {vdm}
----
rule_232c: Bus * Frame * FmiModelDescription * Terminal +> bool
rule_232c(busDesc, frameDesc, modelDesc, frameTerminal) == allOf
([
	let clockName = busDesc.name ^ "::" ^ frameDesc.name ^ "_CLOCK" in allOf
	([
		let var = lookup(modelDesc, clockName) in
			-- @OnFail("Missing ModelVariable for %s", clockName)
			( var <> nil )

			-- @OnFail("Variable is not of type Clock: %s", clockName)
			and ( is_Clock(var) ),	

		-- @OnFail("Missing TerminalMemberVariable for %s", clockName)
		( exists tmv in seq frameTerminal.terminalMemberVariable &
				tmv.variableName = clockName )
	]),

	-- @OnFail("TerminalStreamMemberVariables must be empty at %s",
	-- loc2str(frameTerminal.location))
	( frameTerminal.terminalStreamMemberVariable = nil ),

	-- @OnFail("Frame has wrong number of PDUs at %s",
	-- loc2str(frameTerminal.location))
	( frameTerminal.terminal <> nil
		and len frameTerminal.terminal = len frameDesc.pdus )
]);
----
// {vdm}
See [<<apply_2.3.2c, Frame elements>>]


==== Rule 2.3.3a [[rule_2.3.3a]]
_[Explanation here]_.

// {vdm}
----
rule_233a: Frame * Terminal +> bool
rule_233a(frameDesc, frameTerminal) == allOf
([
	-- @OnFail("Missing 'pdu' Terminal for %s", pdu.name)
	( exists p in seq frameTerminal.terminal & p.name = pdu.name )

	| pdu in seq frameDesc.pdus
]);
----
// {vdm}
See [<<apply_2.3.3a, PDU terminal>>]

==== Rule 2.3.3b [[rule_2.3.3b]]
_[Explanation here]_.

// {vdm}
----
rule_233b: PDU * Terminal +> bool
rule_233b(pduDesc, pduTerminal) == allOf
([
	-- @OnFail("PDU terminal must be terminalKind 'frame' at %s",
	-- loc2str(pduTerminal.location))
	( pduTerminal.terminalKind = "pdu" ),

	-- @OnFail("PDU temrinal must have matchingRule 'bus' at %s")
	-- loc2str(pduTerminal.location))
	( pduTerminal.matchingRule = "bus" ),

	-- @OnFail("PDU %s does not match network description name %s at %s",
	-- pduTerminal.name, pduDesc.name, loc2str(pduTerminal.location))
	( pduTerminal.name = pduDesc.name )
]);
----
// {vdm}
See [<<apply_2.3.3b, PDU attributes>>]

==== Rule 2.3.3c [[rule_2.3.3c]]
_[Explanation here]_.

// {vdm}
----
rule_233c: PDU * Terminal +> bool
rule_233c(pduDesc, pduTerminal) == allOf
([
	-- @OnFail("TerminalStreamMemberVariables must be empty at %s",
	-- loc2str(pduTerminal.location))
	( pduTerminal.terminalStreamMemberVariable = nil ),

	-- @OnFail("PDU can have no Terminals at %s", loc2str(pduTerminal.location))
	( pduTerminal.terminal = nil ),

	-- @OnFail("PDU has wrong number of signals at %s",
	-- loc2str(pduTerminal.location))
	( pduTerminal.terminalMemberVariable <> nil
		and len pduTerminal.terminalMemberVariable = len pduDesc.signals )
]);
----
// {vdm}
See [<<apply_2.3.3c, PDU elements>>]

==== Rule 2.3.4a [[rule_2.3.4a]]
_[Explanation here]_.

// {vdm}
----
rule_234a: PDU * Terminal +> bool
rule_234a(pduDesc, pduTerminal) == allOf
([
	-- @OnFail("PDU has wrong number of signals at %s",
	-- loc2str(pduTerminal.location))
	( pduTerminal.terminalMemberVariable <> nil
		and len pduTerminal.terminalMemberVariable = len pduDesc.signals )
]);
----
// {vdm}
See [<<apply_2.3.4a, Signal variable>>]

==== Rule 2.3.4b [[rule_2.3.4b]]
_[Explanation here]_.

// {vdm}
----
rule_234b: Signal * FmiModelDescription * TerminalMemberVariable +> bool
rule_234b(signalDesc, modelDesc, signalVariable) == allOf
([
	-- @OnFail("Signal must be variableKind 'signal' at %s",
	-- loc2str(signalVariable.location))
	( signalVariable.variableKind = "signal" ),

	-- @OnFail("Signal memberName should be '%s' at %s",
	-- signalDesc.name, loc2str(signalVariable.location))
	( signalVariable.memberName = signalDesc.name ),

	let var = lookup(modelDesc, signalVariable.variableName) in
		-- @OnFail("Signal variable %s is not defined", signalVariable.variableName)
		(var <> nil)
]);
----
// {vdm}
See [<<apply_2.3.4b, Signal attributes>>]

==== Network Description Validation
This section defines the complete validation of a <<network description file>> against a TerminalsAndIcons XML structure, using the basic rules defined above.

// {vdm}
----
networkValidation: NetworkDescription * FmiModelDescription * FmiTerminalsAndIcons +> bool
networkValidation(networkDesc, modelDesc, terminalsAndIcons) == allOf
([
	rule_231a(networkDesc, terminalsAndIcons)
]
^
[
	let matching = {b | b in seq terminalsAndIcons.terminals &
		b.name = busDesc.name }
	in
		-- @OnFail("Missing or duplicate bus terminal for %s", busDesc.name)
		( card matching = 1 )
			=> let {busTerminal} = matching in
				busValidation(busDesc, modelDesc, busTerminal)

	| busDesc in seq networkDesc
]);

busValidation: Bus * FmiModelDescription * Terminal +> bool
busValidation(busDesc, modelDesc, busTerminal) == allOf
([
	rule_231b(busDesc, busTerminal),
	rule_231c(busDesc, modelDesc, busTerminal),
	rule_232a(busDesc, busTerminal)
]
^
[
	let matching = {f | f in seq busTerminal.terminal & f.name = frameDesc.name } in
		-- @OnFail("Missing or duplicate frame for %s", frameDesc.name)
		( card matching = 1 )
			=> let {frameTerminal} = matching in
				frameValidation(busDesc, frameDesc, modelDesc, frameTerminal)
		
	| frameDesc in seq busDesc.frames
]);

frameValidation: Bus * Frame * FmiModelDescription * Terminal +> bool
frameValidation(busDesc, frameDesc, modelDesc, frameTerminal) == allOf
([
	rule_232b(frameDesc, frameTerminal),
	rule_232c(busDesc, frameDesc, modelDesc, frameTerminal),
	rule_233a(frameDesc, frameTerminal)
]
^
[
	let matching = {p | p in seq frameTerminal.terminal & p.name = pduDesc.name } in
		-- @OnFail("Missing or duplicate PDU for %s", pduDesc.name)
		( card matching = 1 )
			=> let {pduTerminal} = matching in
				pduValidation(busDesc, frameDesc, pduDesc, modelDesc, pduTerminal)
		
	| pduDesc in seq frameDesc.pdus
]);

pduValidation: Bus * Frame * PDU * FmiModelDescription * Terminal +> bool
pduValidation(busDesc, frameDesc, pduDesc, modelDesc, pduTerminal) == allOf
([
	rule_233b(pduDesc, pduTerminal),
	rule_233c(pduDesc, pduTerminal)
]
^
[
	let matching = {s | s in seq pduTerminal.terminalMemberVariable &
		s.variableName =
			busDesc.name ^ "::" ^
			frameDesc.name ^ "::" ^
			pduDesc.name ^ "::" ^
			signalDesc.name}
	in
		-- @OnFail("Missing or duplicate TerminalMemberVariable for %s", signalDesc.name)
		( card matching = 1 )
			=> let {signalVariable} = matching in
				signalValidation(signalDesc, modelDesc, signalVariable)
		
	| signalDesc in seq pduDesc.signals
]);

signalValidation: Signal * FmiModelDescription * TerminalMemberVariable +> bool
signalValidation(signalDesc, modelDesc, signalVariable) == allOf
([
	-- @OnFail("Signal must be variableKind 'signal' at %s",
	-- loc2str(signalVariable.location))
	( signalVariable.variableKind = "signal" ),

	-- @OnFail("Signal memberName should be '%s' at %s",
	-- signalDesc.name, loc2str(signalVariable.location))
	( signalVariable.memberName = signalDesc.name ),

	let var = lookup(modelDesc, signalVariable.variableName) in
		-- @OnFail("Signal variable %s is not defined", signalVariable.variableName)
		(var <> nil)
]);
----
// {vdm}


// This adds the document references that the tools use to report links in errors.
ifdef::hidden[]
// {vdm}
values
docReferences : ReferenceMap =
{
	"rule_231a" |-> [ "<LS_BUS_STANDARD>#apply_231a" ],
	"rule_231b" |-> [ "<LS_BUS_STANDARD>#apply_231b" ],
	"rule_231c" |-> [ "<LS_BUS_STANDARD>#apply_231c" ],
	"rule_232a" |-> [ "<LS_BUS_STANDARD>#apply_232a" ],
	"rule_232b" |-> [ "<LS_BUS_STANDARD>#apply_232b" ],
	"rule_232c" |-> [ "<LS_BUS_STANDARD>#apply_232c" ],
	"rule_233a" |-> [ "<LS_BUS_STANDARD>#apply_233a" ],
	"rule_233b" |-> [ "<LS_BUS_STANDARD>#apply_233b" ],
	"rule_233c" |-> [ "<LS_BUS_STANDARD>#apply_233c" ],
	"rule_234a" |-> [ "<LS_BUS_STANDARD>#apply_234a" ],
	"rule_234b" |-> [ "<LS_BUS_STANDARD>#apply_234b" ]
}
// {vdm}
endif::[]
