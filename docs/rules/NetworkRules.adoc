//*********************************************************************************
//
//	Copyright (c) 2017-2022, INTO-CPS Association,
//	c/o Professor Peter Gorm Larsen, Department of Engineering
//	Finlandsgade 22, 8200 Aarhus N.
//
//	MIT Licence:
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy of
//	this software and associated documentation files (the "Software"), to deal in
//	the Software without restriction, including without limitation the rights to use,
//	copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
//	Software, and to permit persons to whom the Software is furnished to do so,
//	subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
//	INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
//	PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
//	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
//	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//	SPDX-License-Identifier: MIT
//
//********************************************************************************/

=== Introduction

This Network Communication Standard contains a complete description of how to define network signals as input and output variables within an FMU.

This appendix defines formal rules that clarify the textual description in the Standard. The formal rules can be used to automatically test the compliance of an FMU with the Standard. Each rule contains links to places in the Standard where the rule is relevant. Similarly, links in the Standard refer to the rules given in this appendix.

The rules only cover the _static_ semantics of the Standard. That is, they describe the rules for correctly configured XML files, not the subsequent _dynamic_ behaviour of the FMUs.

=== VDM-SL Specifications

The rules are defined in VDM-SL, the specification language of the https://en.wikipedia.org/wiki/Vienna_Development_Method[Vienna Development Method].  The language has a formal semantics, enabling proof of the properties of models to a high level of assurance. It also has an executable subset, so that real world data can be processed.

Free https://github.com/overturetool/vdm-vscode[open source tools] are available to process the VDM-SL rules, and https://github.com/INTO-CPS-Association/FMI-VDM-Model/releases[check FMUs for compliance].

=== The VDM-SL Network Description type

In order to define rules for a correctly configured XML files, the various formats of the <<NetworkDescriptionFile>> must be represented as a common VDM-SL record type. This type is an abstract representation of the aspects of the real network description that matter to the rules.

----
types
	NetworkDescription = seq1 of Bus;

	Bus ::
		name	: seq1 of char
		frames	: set1 of Frame;

	Frame ::
		name	: seq1 of char
		pdus	: set1 of PDU;

	PDU ::
		name	: seq1 of char
		signals	: set1 of Signal;

	Signal ::
		name	: seq1 of char
		unit	: [Unit];
----

=== Rules

// This adds the "functions" section header for VDM
ifdef::hidden[]
// {vdm}
functions
// {vdm}
endif::[]

==== Rule 1 [[rule_1]]
Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminal,frame terminals>>. The attribute `name` of the `<Terminal>` must match the root name of its <<NetworkDescriptionFile>>.
// {vdm}
----
rule_1: NetworkDescription * FmiTerminalsAndIcons +> bool
rule_1(nd, ti) == allOf
([
	-- @OnFail("Missing 'bus' Terminal for %s", bus.name)
	( exists terminal in seq ti.terminals & terminal.name = bus.name )

	| bus in seq nd
]);
----
// {vdm}
See [<<apply_rule_1, Bus terminal>>] _[In general, this can be a list of places where the rule is relevant]_

==== Rule 2 [[rule_2]]
A bus terminal `terminalKind` must be set to `bus`, the `matchingRule` must be set to `bus` and the `name` is the network name, e.g. `Powertrain`.
// {vdm}
----
rule_2: Bus * Terminal +> bool
rule_2(busDescription, busTerminal) == allOf
([
	-- @OnFail("Bus terminal must be terminalKind 'bus' at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminalKind = "bus" ),

	-- @OnFail("Bus temrinal must have matchingRule 'bus' at %s")
	-- loc2str(busTerminal.location))
	( busTerminal.matchingRule = "bus" ),

	-- @OnFail("Bus %s does not match network description name %s at %s",
	-- busTerminal.name, busDescription.name, loc2str(busTerminal.location))
	( busTerminal.name = busDescription.name ),

	-- @OnFail("Bus has wrong number of frames at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminal <> nil
		and len busTerminal.terminal = card busDescription.frames )
]);
----
// {vdm}
See [<<apply_rule_2, Bus attributes>>]

==== Rule 3 [[rule_3]]
If frame variables (`BusName::FRAMES_in` and `BusName::FRAMES_out`) and their clocks (`BusName::FRAMES_in_CLOCK` and `BusName::FRAMES_out_CLOCK`) are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here. There must be no `<TerminalStreamMemberVariable>` element.
// {vdm}
----
rule_3: Bus * FmiModelDescription * Terminal +> bool
rule_3(busDescription, modelDescription, busTerminal) == allOf
([
	let variableName = busDescription.name ^ "::" ^ varName in
		-- @OnFail("Missing TerminalMemberVariable for %s", variableName)
		( lookup(modelDescription, variableName) <> nil =>
			exists tmv in seq busTerminal.terminalMemberVariable &
				tmv.variableName = variableName )

	| varName in seq
		[ "FRAMES_in", "FRAMES_out", "FRAMES_in_CLOCK", "FRAMES_out_CLOCK" ]
]
^
[
	-- @OnFail("TerminalStreamMemberVariables must be empty at %s",
	-- loc2str(busTerminal.location))
	( busTerminal.terminalStreamMemberVariable = nil )
]);
----
// {vdm}
See [<<apply_rule_3, Bus elements>>]


// This adds the document references that the tools use to report links in errors.
ifdef::hidden[]
// {vdm}
values
docReferences : ReferenceMap =
{
	"rule_1"		|-> [ "<LS_BUS_STANDARD>#apply_rule_1" ],
	"applyRule_2"	|-> [ "<LS_BUS_STANDARD>#apply_rule_2" ],
	"applyRule_3"	|-> [ "<LS_BUS_STANDARD>#apply_rule_3" ]
}
// {vdm}
endif::[]
