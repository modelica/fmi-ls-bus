== Network Abstraction ("low cut") [[network-abstraction]]
This chapter describes the network abstraction or "low cut" in detail.

=== Overview
The network abstraction allows the implementation of virtual bus drivers within FMUs on the level of the hardware abstraction layer.
Exchanging data in terms of the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> via variables grouped by a dedicated bus terminal (see <<low-cut-tx-rx-clock-variables>>), allows the implementation of bus simulations in a wide range from idealized up to detailed behavior, including e.g., timing, arbitration, error, status and other effects.
During simulation, the network communication is controlled by send and receive bus operations.
Based on these operations, Network FMUs have to react as specified by this layered standard depending on their role.
This role can be a Bus Simulation FMU or an importer with bus simulation support on one side, and Network FMUs (e.g., virtual ECUs) on the other side (see <<common-concepts-system-compositions, System Compositions>>).
The Layered Standard Bus Protocol in general is bus-type-specific, but has some similarities.
Bus communication often follows a Transmit/Confirm pattern, where a Network FMU sends a Transmit operation containing the network message as payload.
Depending on the <<common-concepts-system-compositions, System Composition>>, the importer forwards the Transmit operation either directly to receiving FMUs or to a dedicated bus simulation.
The Bus Simulation then might delay the transfer of the Transmit operation to the receiving FMUs to simulate timing behavior, before sending a bus-specific Confirm operation back to the sending FMU.

.Transmission overview.
[#figure-transmission-overview]
image::transmit_messages.svg[width=50%, align="center"]

The point in time at which FMUs will (potentially) send new network messages can be given to the importer in advance with the proper clock type.
Based on these times, the importer has to calculate the next `communicationStepSize` for all networked FMUs.
For simulating bus communication with timing effects, the FMUs should set the Co-Simulation attribute `canHandleVariableCommunicationStepSize = "true"`.

.Example for network simulation with timing behavior.
[#figure-transmission-example-with-timing-behavior]
image::bus_simulation_example.svg[width=80%, align="center"]

For simplification reasons or if a detailed bus simulation is not desired, fixed-step size FMUs can also be used with network abstraction.
However, depending on the chosen simulation step-size, delay effects of the bus simulation have to be taken into account.
Compositions with fixed-step size and variable-step size FMUs require the decoupling of the Bus Simulation logic and the Bus Simulation timing.
This decoupling is realized by queuing Tx/Rx bus operations inside the Bus Simulation as well as queuing Tx bus operations inside Network FMUs.
By queuing bus operations, System Compositions with variable-step size FMUs as well as fixed-step size FMUs can be simulated together without affecting each other.

=== Layered Standard Bus Protocol [[low-cut-layered-standard-bus-protocol]]
The Layered Standard Bus Protocol allows the transmission of bus operations between FMUs in binary form via clocks and clocked variables (see <<low-cut-variables>>).
Depending on the role (Network or Bus Simulation), FMUs have to respond to received operations as specified by this layered standard.
Operations and the reaction on receipt are bus-type-specific and therefore described in the bus-specific chapters.
However, the description follows a uniform structure and consists of two parts, an overview table and a detailed description of all operations.

The overview table represents the binary format of operations and is structured as follows:

* OP Code: The operation code defines the unique value of the operation.
It consists of one byte in length.
* Total Length: A four byte total data length (OP Code + Total Length + Arguments) field following the OP Code.[[TotalLengthField]]
For operation with variable size arguments, the total length can vary in value at runtime.
* Arguments: The arguments of the respective operation.
The number of arguments is defined for each operation within this standard.
For arguments with a variable length, an argument pair composed of length and data is used.

The following table shows an example of an operation definition.
The name is _OperationName_ and has the OP Code 0x01.
The operation has three arguments _Arg1_ (2 bytes long), _Arg2_Length_ (1 byte long), _Arg2_Data_ (_<Arg2Length>_ bytes long), whereby argument 2 and argument 3 form a coherent variable length argument.

.Definition of an operation within the Layered Standard Bus Protocol.
[#table-operation-definition]
[cols="1,1,1,1,1,1"]
|====
.2+h|Operation Type
5+h|Operation Content

h|OP Code
h|Total Length
3+h|Specific Content

|OperationName
|0x01
|7 + <Arg2_Length>
|1 byte Arg1
|1 byte Arg2_Length
|<Arg2_Length> byte Arg2_Data
|Yes

|====

Additionally, all operations are described separately in detail in the following structure:

.Operation example within the Layered Standard Bus Protocol.
[#table-operation-definition-example]
[cols="5,4,3,20"]
|====
h|Name
3+|Name of the operation _(e.g., OperationName)_
h|Description
3+|Contains a description of the specified operation.
h|OP Code [hex]
3+|OP code of the operation _(e.g., 0x01)_
.6+h|Content h|Argument h|Length h|Description
|OP Code
|1 byte
|Contains the OP Code of the specified operation.

|Total Length
|4 byte
|Defines the cumulative length of all arguments in bytes.
The following applies for this operation: `Total Length = 7 + <Arg2_Length>`.

|Arg1
|1 byte
|The first argument of the operation.

|Arg2_Length
|1 byte
|Contains the length of the Arg2_Data argument in bytes.

|Arg2_Data
|n byte
|The second argument of the operation.

h|Behavior
3+|Describes the behavior of a Network FMU and the Bus Simulation in the context of this operation.
_e.g., The specified operation shall be produced by a Network FMU and consumed by the Bus Simulation._

|====

Remarks:

* Numbers shall be transmitted with `little-endian` byte order.
* Since the standard allows to concatenate multiple operations (see <<low-cut-tx-rx-data-variables, Tx/Rx Data Variables>>), the <<TotalLengthField, Total Length>> field was introduced to allow the implementation of a generic parser for received operations.

==== Format Error [[low-cut-format-error-operation]]
The Format Error operation is independent from the bus type and shall be used when encountering a syntax or content error of received operations.

.Detailed description of the Format Error operation.
[#table-format-error-operation]
[cols="5,4,3,20"]
|====
h|Name
3+|Format Error
h|Description
3+|Represents a generic format operation error, which can be initiated by every operation.
This error shall be used when generally encountering a problem with the syntax or content of an operation.
h|OP Code [hex]
3+|0x01
.4+h|Content
h|Argument
h|Length
h|Description

|OP Code
|1 byte
|Contains the OP Code of the specified operation.
For this operation, the OP Code always has the value 0x01 within all bus types.

|Total Length
|4 byte
|Defines the cumulative length of all arguments in bytes.
The following applies for this operation: `Total Length = 5 + Length of Data argument in bytes`.

|Data
|n byte
|Stores the complete binary data of the operation that caused the specified format error.

h|Behavior
3+|The specified operation shall be produced and consumed by Network FMUs and the Bus Simulation.

|====

==== Basic Type Definitions [[low-cut-basic-type-definitions]]
The following basic types are defined for this standard, which apply to all supported buses.
These basic types are used in the bus-specific parts within the operation definitions as operation arguments.

The following values for the boolean basic type are defined:

.Overview of the available boolean values.
[#table-boolean-value-kinds]
[cols="2,1,5"]
|====

h|Boolean h|Value h|Description
|FALSE|0x00|Describes the boolean value: False.
|TRUE|0x01|Describes the boolean value: True.

|====

=== Variables [[low-cut-variables, Variables]]
This section explains how layered standard bus protocol operations are sent and received by FMUs using FMI 3.0 clock and clocked variables footnote:[For details, refer to Functional Mock-up Interface Specification (fmi-standard.org) chapter 2.2.8 Clocks.].
While the former (see <<low-cut-tx-rx-clock-variables, Tx/Rx Clock Variables>>) are used for scheduling and time synchronization, the latter (see <<low-cut-tx-rx-data-variables, Tx/Rx Data Variables>>) are used to carry the layered standard bus protocol operations in binary form.
To summarize, four variables with the following name schema are used:

The input variable `BusName::Rx_Data` is clocked by the clock variable `BusName::Rx_Clock`, both with `causality` set to `input`.

The output variable `BusName::Tx_Data` is clocked by the clock variable `BusName::Tx_Clock`. 
The `causality` for the Tx_Data variable shall be `output`, but for the Tx_Clock variable it depends on the selected clock type (see <<low-cut-tx-time-based-clock-variables, Tx Clock Variables>>).  

Both variable pairs must be listed as member of its corresponding <<low-cut-bus-terminal, Bus Terminal>>.
How to set the `BusName` placeholder is bus-type-specific and therefore described in the bus-specific chapters.

==== Tx Clock Variables [[low-cut-tx-clock-variables]]
As described in the FMI 3.0 specification, clock variables are used to synchronize events between importer and across FMUs.
Since clock variables are strictly related to the `Event Mode`, networked FMUs shall set the Co-Simulation attribute `hasEventMode = "true"` in the model description file.

The point in time where bus operations are transfered from the Tx_Data to the Rx_Data variables is defined by the Tx_Clock variable.
This point is also referred to as the `bus communication point`.
A bus communication point and a regular communication point can take place at the same time, but should be considered as independent by the importer.
In contrast to a regular communication point where input/output variables used in step mode are exchanged, only the clocked Tx/Rx data variables needs to be considered by the importer.

For defining the point in time of a bus communication point, `time-based` or `triggered` clocks can be used for the Tx_Clock variable.
Hence the clock type can influence the bus simulation significantly - the differences should be taken into account.

===== Time-based Tx Clock Variables [[low-cut-tx-time-based-clock-variables]]
A time-based Tx Clock variable allows networked FMUs to annouce a bus communication point for the next simulation step in advance.

.Example Bus Communication Points announced by aperiodic time-based Tx_Clock variables.
[#low-cut-communication-points]
image::low_cut_communication_points.svg[width=100%, align="center"]

The announced Tx time however does not mean that a bus operation really has to be transferred, but that the connected networked FMUs should enter the event mode at that time.
An importer has to determine proper communication step sizes to synchronize networked FMUs at the announced Tx time.

_[Note: While simulation it can happen that no Tx_Data has to be transferred to the Rx_Data variable at the announced Tx time. In this case the retured 'valueSize' of the Tx_Data variable is 0.]_

Even the `causality` of a time-based Tx_Clock variable and a triggered Rx_Clock variable are each `input`. It is allowed to connect both, since a time-based clock variable of an FMU is considered only to be a request to the importer to provide an attendant clock source.
     
.Consideration of time-base Tx_Clock connections.
[#low-cut-time-based-port-connection]
image::low_cut_time_based_port_connection.svg[width=40%, align="center"]  

Because of the common clock source however, both clock variables (Rx/Tx) might get active at the same time.
To make sure that the Rx_Data variables is set properly, an importer has to activate the Rx_Clock variable under consideration of Tx_Data/Rx_Data dependency.

_[Note: For clarity always a direct connection line between the Tx_Clock and Rx_Clock variables is shown in figures of this document.]_

A time-based clock can be `periodic` or `aperiodic`.
Both allows to define bus communication points independently from the regular communication points with fixed or variable distances. 
The difference between the two clock types is listed in the following table.

.Time-based clock properties.
[#table-tx-clock-properties]
[cols="3,1,7"]
|====
h|Clock properties h|intervalVariability h|Description
|periodic|constant|The bus communication point interval is defined in the modelDescription.xml.
|periodic|fixed|The bus communication point interval is defined in the modelDescription.xml or must be provided in Initialization Mode.
|periodic|tunable|The bus communication point interval is defined in the modelDescription.xml or must be provided in Initialization Mode and can be changed in EventMode.
|aperiodic|changing|The bus communication point interval must be provided in Initialization Mode and can be changed in EventMode if this clock ticked.
|aperiodic|countdown|The bus communication point interval must be provided in Initialization Mode and can be changed in every EventMode.
|====

Network FMUs using a time-based Tx_Clock variable should set the Co-Simulation attribute `canHandleVariableCommunicationStepSize = "true"` in the model description file, since `fmi3DoStep` is typically called with variable `communicationStepSize`.

===== Triggered Tx Clock Variables [[low-cut-tx-triggered-clock-variables]]
A `triggered` clock basically allows to signal events when returning from `fmi3DoStep` either by using an `Early Return` or when the requested communication point at latexmath:[t_{i+1}] was reached.
Since signaling Tx_Clock events with an early return at latexmath:[t < t_{i+1}] would require to set connected networked FMUs back in time to reach bus communication points synchronously, a triggered Tx_Clock variable must only be set when returning from `fmi3DoStep` with the `earlyReturn` argument set to `fmi3False`.
In consequence, bus communication points and regular communication points coincide and take place at the same time.
The time of a bus communication point can therefore not be defined independently, but is given by the importer.
Pending Tx data shall be signaled by returning from fmi3DoStep with the `eventHandlingNeeded` arguments set to `fmi3True`.

.Triggered Tx_Clock/Rx_Clock connection.
[#low-cut-triggered-port-connection]
image::low_cut_communication_with_triggered_tx_clock.svg[width=100%, align="center"]  


==== Rx Clock Variables [[low-cut-rx-clock-variables]]
The input clocks (`Rx_Clock`) shall be triggered clocks.

==== Tx/Rx Data Variables [[low-cut-tx-rx-data-variables, Communication Variables]]
The Tx/Rx variables are of type `fmi3Binary` and contain multiple bus operations, as sent or receive by the FMU.
If no bus operations shall be sent by a specified Network FMU at a given bus communication point, the size of the corresponding binary `Tx_Data` variable shall be set to zero.
The senders can choose how many bus operations are buffered and/or for how long operations are buffered before activating an output clock to trigger the actual sending of these operations.
This allows senders to trade accuracy for speed: buffering more and interrupting the simulation less will lead to faster simulations, but less accurate timing of the network communication.

==== Selecting the type of Tx Clock[[low-cut-selecting_tx_variables]]
Selecting suitable Tx variables allows the FMU (or better the exporting tool) to balance the accuracy and performance of its network communication:

 - While aperiodic clocks allow very accurate network simulations, frequently entering `Event Mode` will reduce the network simulation speed.
 - Using periodic clocks and queueing the operations to be transmitted reduces the number of `Event Mode` entries and speeds up the simulation at the cost of simulation accuracy.
 - One could use (structural) parameters to define the accuracy of aperiodic clocks, allowing control of the simulation accuracy and performance with the same FMU.

==== MIME Types
Within FMI, every binary FMI variable has a `mimeType`, which indicates the type of data passed as a binary.
This type indicates which specific bus type is involved.
It ensures that only bus types of the same type can be interconnected, since FMI only allows the connection of two MIME types of the same binary variables.
The following table lists the names of MIME types used for the Tx/Rx data variables:

.Overview of the available MIME types for the supported several bus types.
[#table-mime-types]
[cols="4,5",options="header"]
|====
|MIME type name
|Description

|org.fmi-standard.fmi-ls-bus.v1.can
|Binary variables simulating the automotive CAN network including CAN, CAN FD and CAN XL

|org.fmi-standard.fmi-ls-bus.v1.lin
|Binary variables simulating the automotive LIN network

|org.fmi-standard.fmi-ls-bus.v1.flexray
|Binary variables simulating the automotive FlexRay network

|org.fmi-standard.fmi-ls-bus.v1.ethernet
|Binary variables simulating the automotive Ethernet network

|org.fmi-standard.fmi-ls-bus.v1.spi
|Binary variables simulating the automotive SPI network

|====

As in the table, above the version of a specified bus type is integrated within the MIME type.
The MIME type and the associated versioning ensure that only compatible bus types can be connected to each other.
The version number marks the set of available operations.
Only the major version is included by the specified MIME type.
The versioning follows the rules of semantic versioning, as defined in <<PW13>>.

=== Terminal Definitions
This section defines terminals for network abstraction or "low cut".

==== Bus Terminal [[low-cut-bus-terminal,bus terminal]]
Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>`.
The attribute `name` of the `<Terminal>` must match the name of the specified network _[e.g., the name of the CAN channel: Powertrain]_ within a "low cut".
If the specified FMU is connected to more than one network, there shall be exactly one `<Terminal>` for each network.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g., `Powertrain`, see <<low-cut-example, example>> and constraints.

Element definitions::
 * `BusName::Rx_Data` and `BusName::Tx_Data` and their clocks `BusName::Rx_Clock` and `BusName::Tx_Clock` are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here.
 * There must be no `<TerminalStreamMemberVariable>` element.

The <<#figure-frame-variables-terminals-lowcut, following figure>> shows a FMU with four variables `Tx_Data`, `Tx_Clock`, `Rx_Data`, `Rx_Clock` that are aggregated to a `<Terminal>` named _Bus Terminal_:

.Frame variables and terminals.
[#figure-frame-variables-terminals-lowcut]
image::bus_terminal.svg[width=30%, align="center"]

==== Example [[low-cut-example]]
The following excerpts from files are used throughout this document as examples and illustrate how the different concepts relate.

.Example modelDescription.xml for ECU node
[#modelDescriptionLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription_lowCut.xml[]
----

The following file shows the `<Terminal>` related definition:

.Example terminalsAndIcons.xml file
[#terminalsAndIconLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons_lowCut.xml[]
----

//=== Network Parameters [[NetworkParameters]]
//Using structural parameters, FMUs can be parameterized according to importer specifications.
//This subchapter specifies the structural parameters that each FMU shall provide.

=== Bus-Specific Details [[low-cut-bus-specific-details]]
For each supported bus type, the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> is defined.
This chapter describes the operations of the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> to enable the simulation of supported bus types.

include::4_4_1_can.adoc[]

include::4_4_2_lin.adoc[]

include::4_4_3_flexray.adoc[]

include::4_4_4_ethernet.adoc[]
