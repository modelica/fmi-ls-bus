== Network Abstraction ("low cut") [[network-abstraction]]
This chapter describes the network abstraction or "low cut" in detail.

=== Overview
The network abstraction allows the implementation of virtual bus drivers within FMUs on the level of the hardware abstraction layer.
Exchanging data in terms of the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> via variables grouped by a dedicated bus terminal (see <<low-cut-tx-rx-clock-variables>>), allows the implementation of bus simulations in a wide range from idealized up to detailed behavior, including e.g., timing, arbitration, error, status and other effects.
During simulation, the network communication is controlled by send and receive bus operations.
Based on these operations, Network FMUs have to react as specified by this layered standard depending on their role.
This role can be a Bus Simulation FMU or an importer with bus simulation support on one side, and Network FMUs (e.g., virtual ECUs) on the other side (see <<common-concepts-system-compositions, System Compositions>>).
The Layered Standard Bus Protocol in general is bus-type-specific, but has some similarities.
Bus communication often follows a Transmit/Confirm pattern, where a Network FMU sends a Transmit operation containing the network message as payload.
Depending on the <<common-concepts-system-compositions, System Composition>>, the importer forwards the Transmit operation either directly to receiving FMUs or to a dedicated bus simulation.
The Bus Simulation then might delay the transfer of the Transmit operation to the receiving FMUs to simulate timing behavior, before sending a bus-specific Confirm operation back to the sending FMU.

.Transmission overview.
[#figure-transmission-overview]
image::transmit_messages.svg[width=50%, align="center"]

The point in time at which FMUs will (potentially) send new network messages can be given to the importer in advance with the proper clock type.
Based on these times, the importer has to calculate the next `communicationStepSize` for all networked FMUs.
For simulating bus communication with timing effects, the FMUs should set the Co-Simulation attribute `canHandleVariableCommunicationStepSize = "true"`.

.Example for network simulation with timing behavior.
[#figure-transmission-example-with-timing-behavior]
image::bus_simulation_example.svg[width=80%, align="center"]

For simplification reasons or if a detailed bus simulation is not desired, fixed-step size FMUs can also be used with network abstraction.
However, depending on the chosen simulation step-size, delay effects of the bus simulation have to be taken into account.
Compositions with fixed-step size and variable-step size FMUs require the decoupling of the Bus Simulation logic and the Bus Simulation timing.
This decoupling is realized by queuing Tx/Rx bus operations inside the Bus Simulation as well as queuing Tx bus operations inside Network FMUs.
By queuing bus operations, System Compositions with variable-step size FMUs as well as fixed-step size FMUs can be simulated together without affecting each other.

=== Layered Standard Bus Protocol [[low-cut-layered-standard-bus-protocol]]
The Layered Standard Bus Protocol allows the transmission of bus operations between FMUs in binary form via clocks and clocked variables (see <<low-cut-variables>>).
Depending on the role (Network or Bus Simulation), FMUs have to respond to received operations as specified by this layered standard.
Operations and the reaction on receipt are bus-type-specific and therefore described in the bus-specific chapters.
However, the description follows a uniform structure and consists of two parts, an overview table and a detailed description of all operations.

The overview table represents the binary format of operations and is structured as follows:

* OP Code: The operation code defines the unique value of the operation.
It consists of one byte in length.
* Total Length: A four byte total data length (OP Code + Total Length + Arguments) field following the OP Code.[[TotalLengthField]]
For operation with variable size arguments, the total length can vary in value at runtime.
* Arguments: The arguments of the respective operation.
The number of arguments is defined for each operation within this standard.
For arguments with a variable length, an argument pair composed of length and data is used.

The following table shows an example of an operation definition.
The name is _OperationName_ and has the OP Code 0x01.
The operation has three arguments _Arg1_ (2 bytes long), _Arg2_Length_ (1 byte long), _Arg2_Data_ (_<Arg2Length>_ bytes long), whereby argument 2 and argument 3 form a coherent variable length argument.

.Definition of an operation within the Layered Standard Bus Protocol.
[#table-operation-definition]
[cols="1,1,1,1,1,1"]
|====
.2+h|Operation Type
5+h|Operation Content

h|OP Code
h|Total Length
3+h|Specific Content

|OperationName
|0x01
|7 + <Arg2_Length>
|1 byte Arg1
|1 byte Arg2_Length
|<Arg2_Length> byte Arg2_Data
|Yes

|====

Additionally, all operations are described separately in detail in the following structure:

.Operation example within the Layered Standard Bus Protocol.
[#table-operation-definition-example]
[cols="5,4,3,20"]
|====
h|Name
3+|Name of the operation _(e.g., OperationName)_
h|Description
3+|Contains a description of the specified operation.
h|OP Code [hex]
3+|OP code of the operation _(e.g., 0x01)_
.6+h|Content h|Argument h|Length h|Description
|OP Code
|1 byte
|Contains the OP Code of the specified operation.

|Total Length
|4 byte
|Defines the cumulative length of all arguments in bytes.
The following applies for this operation: `Total Length = 7 + <Arg2_Length>`.

|Arg1
|1 byte
|The first argument of the operation.

|Arg2_Length
|1 byte
|Contains the length of the Arg2_Data argument in bytes.

|Arg2_Data
|n byte
|The second argument of the operation.

h|Behavior
3+|Describes the behavior of a Network FMU and the Bus Simulation in the context of this operation.
_e.g., The specified operation shall be produced by a Network FMU and consumed by the Bus Simulation._

|====

Remarks:

* Numbers shall be transmitted with `little-endian` byte order.
* Since the standard allows to concatenate multiple operations (see <<low-cut-tx-rx-data-variables, Tx/Rx Data Variables>>), the <<TotalLengthField, Total Length>> field was introduced to allow the implementation of a generic parser for received operations.

==== Format Error [[low-cut-format-error-operation]]
The Format Error operation is independent from the bus type and shall be used when encountering a syntax or content error of received operations.

.Detailed description of the Format Error operation.
[#table-format-error-operation]
[cols="5,4,3,20"]
|====
h|Name
3+|Format Error
h|Description
3+|Represents a generic format operation error, which can be initiated by every operation.
This error shall be used when generally encountering a problem with the syntax or content of an operation.
h|OP Code [hex]
3+|0x01
.4+h|Content
h|Argument
h|Length
h|Description

|OP Code
|1 byte
|Contains the OP Code of the specified operation.
For this operation, the OP Code always has the value 0x01 within all bus types.

|Total Length
|4 byte
|Defines the cumulative length of all arguments in bytes.
The following applies for this operation: `Total Length = 5 + Length of Data argument in bytes`.

|Data
|n byte
|Stores the complete binary data of the operation that caused the specified format error.

h|Behavior
3+|The specified operation shall be produced and consumed by Network FMUs and the Bus Simulation.

|====

==== Basic Type Definitions [[low-cut-basic-type-definitions]]
The following basic types are defined for this standard, which apply to all supported buses.
These basic types are used in the bus-specific parts within the operation definitions as operation arguments.

The following values for the boolean basic type are defined:

.Overview of the available boolean values.
[#table-boolean-value-kinds]
[cols="2,1,5"]
|====

h|Boolean h|Value h|Description
|FALSE|0x00|Describes the boolean value: False.
|TRUE|0x01|Describes the boolean value: True.

|====

=== Variables [[low-cut-variables, Variables]]
This section explains how layered standard bus protocol operations are sent and received by FMUs using FMI 3.0 clock and clocked variables footnote:[For details, refer to Functional Mock-up Interface Specification (fmi-standard.org) chapter 2.2.8 Clocks.].
While the former (see <<low-cut-tx-rx-clock-variables, Tx/Rx Clock Variables>>) are used for scheduling and time synchronization, the latter (see <<low-cut-tx-rx-data-variables, Tx/Rx Data Variables>>) are used to carry the layered standard bus protocol operations in binary form.
To summarize, four variables with the following name schema are used:

The input variable `BusName::Rx_Data` is clocked by the clock variable `BusName::Rx_Clock`, both with `causality` set to `input`.

The output variable `BusName::Tx_Data` is clocked by the clock variable `BusName::Tx_Clock`, both with `causality` set to `output`.

Both variable pairs must be listed as member of its corresponding <<low-cut-bus-terminal, Bus Terminal>>.
How to set the `BusName` placeholder is bus-type-specific and therefore described in the bus-specific chapters.

==== Tx/Rx Clock Variables [[low-cut-tx-rx-clock-variables]]
As described in the FMI 3.0 specification, clock variables are used to synchronize events between importer and across FMUs.
Since clock variables are strictly related to the `Event Mode`, networked FMUs shall set the Co-Simulation attribute `hasEventMode = "true"` in the model description file.

For simulating bus communication according to the network abstraction, a time-based clock is used for the `Tx_Clock` variable to signal the point in time when layered standard bus operations must be transferred by the importer to the receiver FMUs.
It is up to the implementer to either use a `periodic` or `aperiodic` clock.

This allows the FMU (or better the exporting tool) to balance the accuracy and performance of its network communication:

 - While aperiodic clocks allow very accurate network simulations, frequently entering `Event Mode` will reduce the network simulation speed.
 - Using periodic clocks and queuing the operations to be transmitted reduces the number of `Event Mode` entries and speeds up the simulation at the cost of simulation accuracy.
 - One could use (structural) parameters to define the accuracy of aperiodic clocks, allowing control of the simulation accuracy and performance with the same FMU.

The input clocks (`Rx_Clock`) shall be triggered clocks.

The importer will then connect and merge output clock activations, even those of different clock types, and forward them to the input clocks, as required by the network semantics.

===== Bus Communication Points [[low-cut-bus-communication-points]]
For transferring bus operations from the `Tx_Data` to the `Rx_Data` variables, networked FMUs must be synchronous in time.
This point in time is also referred to as the Bus Communication Point.
The importer must ensure that networked FMUs hit such points synchronously by calling `fmi3DoStep` with a proper `communicationStepSize` argument.
To determine the `communicationStepSize` for the first simulation step, the importer gets the Tx clock time in `Initialization Mode` as follows:

* For aperiodic Tx clocks, the importer calls `fmi3GetInterval`.
* For periodic Tx clocks, the importer shall evaluate the clock attributes (e.g., `intervalDecimal`) as defined in the model description.
  If `intervalDecimal` is not defined, the importer shall call `fmi3GetShift`.

Based on the Tx clock intervals received in the `Initialization Mode`, the importer calls `fmi3DoStep` with a determined `communicationStepSize` to reach the next Bus Communication Point.
After returning from `fmi3DoStep`, the importer has to enter the `Event Mode` by calling `fmi3EnterEventMode`.
In `Event Mode`, the importer activates the Tx and Rx clock by calling `fmi3SetClock`.
The importer then starts to transfer bus operations from the `Tx_Data` to the `Rx_Data` variable (see <<low-cut-tx-rx-data-variables>>).

To determine the `communicationStepSize` for the next simulation step, the importer gets the Tx clock time as follows:

* For aperiodic Tx clocks, the importer calls `fmi3GetInterval`.
* For periodic Tx clocks, the importer shall evaluate the clock attributes as defined in the model description.

If an FMU wants to respond to a received bus operation in the same time step, then `fmi3GetInterval` must return 0.
In this case, the importer remains in `Event Mode` and starts a new iteration.
If an FMU does not know the next Tx clock time for any reason, `fmi3GetInterval` shall return with `qualifier = fmi3IntervalNotYetKnown`.

==== Tx/Rx Data Variables [[low-cut-tx-rx-data-variables, Communication Variables]]
The Tx/Rx variables are of type `fmi3Binary` and contain multiple bus operations, as sent or receive by the FMU.
If no bus operations shall be sent by a specified Network FMU at a given Bus Communication Point, the size of the corresponding binary `Tx_Data` variable shall be set to zero.
The senders can choose how many bus operations are buffered and/or for how long operations are buffered before activating an output clock to trigger the actual sending of these operations.
This allows senders to trade accuracy for speed: buffering more and interrupting the simulation less will lead to faster simulations, but less accurate timing of the network communication.

==== MIME Types
Within FMI, every binary FMI variable has a `mimeType`, which indicates the type of data passed as a binary.
This type indicates which specific bus type is involved.
It ensures that only bus types of the same type can be interconnected, since FMI only allows the connection of two MIME types of the same binary variables.
The following table lists the names of MIME types used for the Tx/Rx data variables:

.Overview of the available MIME types for the supported several bus types.
[#table-mime-types]
[cols="4,5",options="header"]
|====
|MIME type name
|Description

|org.fmi-standard.fmi-ls-bus.v1.can
|Binary variables simulating the automotive CAN network including CAN, CAN FD and CAN XL

|org.fmi-standard.fmi-ls-bus.v1.lin
|Binary variables simulating the automotive LIN network

|org.fmi-standard.fmi-ls-bus.v1.flexray
|Binary variables simulating the automotive FlexRay network

|org.fmi-standard.fmi-ls-bus.v1.ethernet
|Binary variables simulating the automotive Ethernet network

|org.fmi-standard.fmi-ls-bus.v1.spi
|Binary variables simulating the automotive SPI network

|====

As in the table, above the version of a specified bus type is integrated within the MIME type.
The MIME type and the associated versioning ensure that only compatible bus types can be connected to each other.
The version number marks the set of available operations.
Only the major version is included by the specified MIME type.
The versioning follows the rules of semantic versioning, as defined in <<PW13>>.

=== Terminal Definitions
This section defines terminals for network abstraction or "low cut".

==== Bus Terminal [[low-cut-bus-terminal,bus terminal]]
Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>`.
The attribute `name` of the `<Terminal>` must match the name of the specified network _[e.g., the name of the CAN channel: Powertrain]_ within a "low cut".
If the specified FMU is connected to more than one network, there shall be exactly one `<Terminal>` for each network.

Attribute definitions::
 * `terminalKind` must be set to `org.fmi-ls-bus.network-terminal`.
 * `matchingRule` must be set to `org.fmi-ls-bus.transceiver`.
 * `name` is the network name, e.g., `Powertrain`, see <<low-cut-example, example>> and constraints.

Element definitions::
 * `BusName::Rx_Data` and `BusName::Tx_Data` and their clocks `BusName::Rx_Clock` and `BusName::Tx_Clock` are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here.
 * There must be no `<TerminalStreamMemberVariable>` element.

The `matchingRule` of type `org.fmi-ls-bus.transceiver` is specified as: `Tx_{Data|Clock}` variables shall be connected to `Rx_{Data|Clock}` variables and vice versa, whereby the variable type shall be equal.

The <<#figure-frame-variables-terminals-lowcut, following figure>> shows a FMU with four variables `Tx_Data`, `Tx_Clock`, `Rx_Data`, `Rx_Clock` that are aggregated to a `<Terminal>` named _Bus Terminal_:

.Frame variables and terminals.
[#figure-frame-variables-terminals-lowcut]
image::bus_terminal.svg[width=30%, align="center"]

==== Example [[low-cut-example]]
The following excerpts from files are used throughout this document as examples and illustrate how the different concepts relate.

.Example modelDescription.xml for ECU node
[#modelDescriptionLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription_lowCut.xml[]
----

The following file shows the `<Terminal>` related definition:

.Example terminalsAndIcons.xml file
[#terminalsAndIconLowCut.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons_lowCut.xml[]
----

//=== Network Parameters [[NetworkParameters]]
//Using structural parameters, FMUs can be parameterized according to importer specifications.
//This subchapter specifies the structural parameters that each FMU shall provide.

=== Bus-Specific Details [[low-cut-bus-specific-details]]
For each supported bus type, the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> is defined.
This chapter describes the operations of the <<low-cut-layered-standard-bus-protocol, Layered Standard Bus Protocol>> to enable the simulation of supported bus types.

include::4_4_1_can.adoc[]

include::4_4_2_lin.adoc[]

include::4_4_3_flexray.adoc[]

include::4_4_4_ethernet.adoc[]
