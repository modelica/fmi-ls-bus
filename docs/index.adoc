= Network Communication and FMI 3.0, v1.0
:doctype: book
:imagesdir: images
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:stylesheet: fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:icons: font

This layered standard on top of FMI 3.0, defines how to describe and simulate network signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2021 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN, LIN, FlexRay, CAN FD and CAN XL are network technologies that have been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such virtual ECUs requires connecting them using a virtual version of these network technologies.

This layered standard defines what input and output variables and which FMI 3.0 features are used and how to emulate a transport layer for such network traffic.

There are mainly two base use cases envisioned here:
 - Physical signal abstraction ("high cut") to simply transport physical signal values between virtual ECUs.
   The network properties are largely idealized: infinite bandwidth, zero-delay etc.
   Signals, groups of signals and their properties (e.g. units) are usually derived from (existing and validated) standard network topology description formats (such as DBC, LDF, Fibex and ARXML).
 - Frame abstraction ("low cut") to facilitate MCAL-level abstractions.
   This transport layer emulation allows idealized and more detailed network simulation, including bandwidth restrictions, message arbitration and delays and it forwards the network payloads using binary variables.
   The "low cut" abstraction layer is meant to allow virtualized MCAL driver implementations, including feedback from the physical drivers about send timing, rejection or network errors.

In the simplest use case, the importer does not need to know about the special network semantics of certain variables of an FMU; it simply forwards variable values between 2 FMUs according to the FMI standard (<<multiOutput,with one exception noted at the end of the document>>).
Only when more than two FMUs are connected to a single network a bus simulation component is required to merge and then forward the network interface semantics of the different variables from multiple output variables to multiple input variables.

See the following image describing three potential architectures for connecting two or more networked virtual ECUs packaged into FMI 3.0 FMUs:

# TODO dSPACE: add image with the use-case architectures (see dSPACE slides)


=== Basic Mechanisms of this Layered Standard

Both abstraction layers are nearly equivalent and can be translated into one another using the <<NetworkDescriptionFile,network description files>>.
Depending on the export tool, one of the abstraction layers is more "natural" to the FMU, while the other might have to be emulated with additional internal effort or an adapter (FMU) could be used.
Importers on the other hand rarely require both abstraction layers for system level compositions, because the engineering tasks define the required level of abstraction for the network communication.
FMUs may choose to only support one abstraction layer providing only the corresponding variables.
However, for versatility, having FMUs capable of communicating on both abstraction layers is more convenient for users.

_[FMUs providing both abstraction layers can deduce from the fmi3Set() and fmi3Get() calls they receive, which abstraction layer the importer is using.]_

Since network communication is not continuous but time discrete, FMI 3.0 clocks are used to indicate when signals and/or frames are sent or received.
All signal and frame variables are clocked variables.

FMI 3.0 terminal definitions in the `terminalsAndIcons.xml` for each level of grouping (networks, frames and PDUs) allow system composition tools without knowledge of the network description format to semantically group signals.
To uniquely map between the FMU variables and the network variables, FMU variable names are structured, e.g. `BusName::FrameName::PDUName::SignalName`.

# TODO AJ: explanation of clock and binary (check names!) variables for low cut; clock type influences and flexibilities; not use of nextEventTime

All variables have structured names that indicate how these variables are related and to which abstraction layer they belong.
For the high cut, variables represent signals and their clocks.
For the low cut, variables represent frames and their clocks.
Input and output variables show if these variables belong to signals or frames that are sent or received.
Input clocks must be triggered and are connected by the importer to their corresponding output clocks of potentially different clock types.
For example, a periodic output clock indicates that the FMU can only send signals or frames periodically, while a countdown clock indicates that the FMU can send signals at varying time steps.

Using output clocks of different types allows simulations with different timing accuracy and performance.
These clocks allow the FMU to specify the next send event efficiently and accurately, the importer will trigger these clocks according to these clock specifications as accurately as it can.

_[The alternative of using `nextEventTime` would force epsilon matching of event times.]_

# TODO AJ: Fix and variable step size influence on buffering of transport-layer events and their binary variables
#  -> high cut is different: no buffering possible: each send must be handled as Event
For any periodic (fixed-time) sending of messages, may force multiple sends into one `doStep`.
While high-cut signal variables will miss all but the last value sent, low-cut frame variables will buffer all payloads inside the binary value.

If an FMU represents network nodes that are both sender and receiver of a signal, the receiver role will be removed from the FMU interface to allow the signals to have a unique role as output and the reading of such outputs must be handled internally to the FMU.

_[The FMI standard requires a variable to be either input or output.]_

# TODO: is this correct? does that also work for network simulations? how else to solve this unique-variable-name requirement?

# TODO AJ: structure of binary variable: event code plus parameters, potentially multiple parameter sets as send and confirm events must be buffered

While the values and semantic of the clock variables are clear, the binary frame variables are opaque to the importer but have internal structure to implement the transport layer of the specific network technology, see <<FrameStructure>>.
Frame variables do not just transport the network-specific payload, but also carry protocol-specific status information.
Status information allows, for example, the MCAL emulation of a virtual ECU to report back to the COM-stack about success or errors of a send request.


== Details

=== Network Description Files [[NetworkDescriptionFile,network description file]]

# TODO AJ: remove old requirements for network description files (not needed anymore): make it optional

Standardized <<NetworkDescriptionFile,network description files>> can be shipped with each FMU to describe properties of signals and frames, such as signal units, frame composition and trigger conditions.
These <<NetworkDescriptionFile,network description files>> must be placed into the `/extra/org.modelica.fmi-ls-bus` folder.
DBC, LDF, Fibex and ARXML files are allowed, e.g. `Powertrain.dbc`.
The case sensitive root name of the <<NetworkDescriptionFile>> must be used as network identifier in the bus terminal type and prefix in the variable names.

Multiple files can be specified, each one defining one network used by the FMU.
This standard does not support composing one network from multiple <<NetworkDescriptionFile,network description files>>, even if using internal include mechanisms, it rather enforces the rule: one network - one file.

It is recommended to use ARXML over DBC files for CAN whenever possible, because the DBC standard lacks some key frame/PDU properties that were added only later using non-standard extensions with different dialects in use.

This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.


=== Variables

This section explains the different variable types used to carry network traffic through FMI input and output variables.

==== Signal Variables

To define the signal abstraction layer (or "high cut"), signal variables are defined.

A signal variable carries the physical value of a network signal normally packaged inside a PDU or frame.
The unit definition of the variable must match the one defined in the <<NetworkDescriptionFile>>.

Each network signal must be listed as <<TerminalMemberVariable>> of its corresponding <<PDUTerminal>>.

In case multiplexed signals are present in a frame/PDU: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive variables have undefined values _[those values could even be outside their specified min-max range without fault]_.

Generally, signal variables are optional, but they must either be all missing or all present to clearly indicate support for the signal abstraction layer.

All signal variables are clocked to indicate when exactly they have been sent, see <<ClockVariable>>.

==== Frame Variables [[FrameVariable]]

# TODO AJ: this needs to change completely: This is now "Data"

To define the frame abstraction layer (or "low cut"), frame variables are defined.

A frame variable is of type `fmi3Binary` and contains one or more binary frames, as sent by the network.
There are two such frame variables per bus: an input and an output.
The names of these frame variables are defined as `BusName::Data_in` and `BusName::Data_out`, e.g. `Powertrain::Data_in` and `Powertrain::Data_out` (see <<Example>>).

# TODO all: names for the frame could use improvement!

Both frame variables must be listed as <<TerminalMemberVariable>> of its corresponding <<BUSTerminal>>.

Generally, frame variables are optional, but they must either both be missing or present to clearly indicate support for the frame abstraction layer.

The senders of network frames can chose how many frames are buffered and/or for how long frames are buffered before activating an output clock to trigger the actual sending of these frames.
This allows senders to trade accuracy for speed: buffering more and interrupting the simulation less will lead to faster simulations, but less accurate timing of the network communication, see <<ClockVariable>>.

# TODO all: MIME types: org.modelica.fmi-ls-bus.v1.[CAN|CANFD|LIN|FlexRay|Ethernet|SPI] -- anything missing? names good?

[#table-math-model-exchange]
[cols="8,3",options="header"]
|====
|MIME type name
|Description

|org.modelica.fmi-ls-bus.v1.CAN
|binary variables simulating the automotive CAN network

|org.modelica.fmi-ls-bus.v1.CANFD
|binary variables simulating the automotive CANFD network

|org.modelica.fmi-ls-bus.v1.LIN
|binary variables simulating the automotive LIN network

|org.modelica.fmi-ls-bus.v1.FlexRay
|binary variables simulating the automotive FlexRay network

|org.modelica.fmi-ls-bus.v1.Ethernet
|binary variables simulating the automotive Ethernet network

|org.modelica.fmi-ls-bus.v1.SPI
|binary variables simulating the automotive SPI network

|====

==== Clock Variables [[ClockVariable]]

# TODO AJ: rework the clock descriptions here; add connection constraints and their semantics
# Names: Rx/Tx and Event/Data: BusName::Rx_Event, BusName::Rx_Data, BusName::Tx_Event, BusName::Tx_Data

# TODO AJ: Add description of Event Mode handling here and how the countdown clock pre-schedules events into the future for performance reasons


In order to use FMU input and output variables as transport layer for networks, aperiodic, triggered input and output clocks are used.
Such a clock is activated by the sender to indicate the transmission of the corresponding frame or frames.

Each frame `BusName::FrameName` has its own dedicated clock variable named `BusName::FrameName_CLOCK`, e.g. `POWERTRAIN::ecuState_CLOCK`, and must be listed as <<TerminalMemberVariable>> of its corresponding <<FrameTerminal>>.

All signal variables are clocked variables.
Signal variables belonging to frame `BusName::FrameName` are triggered by the clock `BusName::FrameName_CLOCK` and all these variables must share the same `causality`.

Each frame variable `BusName::Data_in` and `BusName::Data_out` have their own dedicated clock variable named `BusName::FRAMES_in_CLOCK` and `BusName::FRAMES_out_CLOCK`, e.g. `Powertrain::FRAMES_in_CLOCK` and `Powertrain::FRAMES_out_CLOCK`, respectively, must have the appropriate `causality`, and must be listed as <<TerminalMemberVariable>> of its corresponding <<BUSTerminal>>.

// what about dynamic PDUs? Do they need their own clocks as well?

# TODO AJ: Add description of Event Type and their respective parameters and applicability to the different protoco types (mimic table)


==== Bus Parameters [[BusParameters]]

# TODO AJ: define parameter names and their semantics influencing bus behavior and/or version of the fmi-ls-bus version (FMU declares them as parameters or structural parameters depending on internal mechanisms)

=== Terminal Definitions

==== Bus Terminal [[BUSTerminal,bus terminal]]

# TODO AJ: adjust Terminal definitions for low cut

Each network connected to the FMU must be described in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminal,frame terminals>>.
The attribute `name` of the `<Terminal>` must match the root name of its <<NetworkDescriptionFile>>
_[e.g. `Powertrain`, if the file is `/extra/org.modelica.fmi.layered_BUS/Powertrain.dbc`]_.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g. `Powertrain`, see <<Example>> and constraints above.

Element definitions::
 * If frame variables (`BusName::Data_in` and `BusName::Data_out`) and their clocks (`BusName::FRAMES_in_CLOCK` and `BusName::FRAMES_out_CLOCK`) are exposed in the `modelDescription.xml`, they must be listed as `<TerminalMemberVariable>` elements here.
 These variables represent the frame abstraction layer ("low cut").
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per network frame described in the <<NetworkDescriptionFile>>.

Annotation element::
 * There must be an `<Annotation>` element defining which node or nodes (as comma-separated list without spaces) of the <<NetworkDescriptionFile>> are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a frame and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving such frames must then be handled internally to the FMU.

==== Frame Terminal [[FrameTerminal,frame terminal]]

Each frame listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<BUSTerminal>>.

Attribute definitions::
 * `terminalKind` must be set to `frame`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the frame name as defined in the <<NetworkDescriptionFile>> in `/extra/org.modelica.fmi.layered_BUS`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one <<PDUTerminal>> element per PDU of this frame.
 * There must be one `<TerminalMemberVariable>` for the clock this frame is connected to.
   The name of this variable is composed as <<ClockVariable,`BusName::FrameName_CLOCK`>>, e.g. `Powertrain::tcuSensors_CLOCK`.

The <<TerminalMemberVariable>> must have the same causality as all variables referenced in the <<PDUTerminal,PDU Terminals>> included here.

==== PDU Terminal [[PDUTerminal,PDU terminal]]

Each PDU listed in the <<NetworkDescriptionFile>> must be an element of its corresponding <<FrameTerminal>>.

Attribute definitions::
 * `terminalKind` must be set to `pdu`.
 * `matchingRule` must be set to `bus`.
 * `name` must match a PDU name of the <<NetworkDescriptionFile>> in `/extra/org.modelica.fmi.layered_BUS`.
    For network types not natively referencing a "PDU", like CAN, a synthetic PDU with the same name as its frame is inserted.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per <<TerminalMemberVariable,signal>> of this PDU.

All <<TerminalMemberVariable,`TerminalMemberVariables`>> must have the same causality of either input or output.

==== Terminal Member Variable for Signals [[TerminalMemberVariable,Terminal Member Variable]]

<<PDUTerminal,PDU terminals>> list all the contained signals as `<TerminalMemberVariable>`.

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::FrameName::PDUName::SignalName`, e.g. `Powertrain::tcuSensors::tcuSensors::vCar`.
    These variables represent the signal abstraction layer ("high cut").
 * `memberName` is the `SignalName` as given in the <<NetworkDescriptionFile>>, e.g. `vCar`.
    This is redundant information but simplifies signal name extraction.
 * `variableKind` is `signal`.

=== Example [[Example,Example]]

The following excerpts from files are used throughout this document as examples and should illustrate how the different concepts relate.

The following partial DBC file lists merely the CAN message (frame) structure.
Signal trigger conditions are not included because they have no bearing on this standard.

.Example Powertrain.dbc file
[#Powertrain.dbc]
[source, C]
----
...
BO_ 256 tcuSensors: 4 TCU
 SG_ vCar :          0|16@1- (32,0)  [-500|500] "km/h" ECU
 SG_ oilTemp :      16|9@1-  (2,50)  [-50|150]  "Grad C" ECU

BO_ 257 tcuState: 2 TCU
 SG_ state :         0|2@1+  (1,0)   [ 0|2] "-" ECU
 SG_ gear :          2|4@1-  (1,0)   [-2|6] "-" ECU
 SG_ targetGear :    6|4@1-  (1,0)   [-2|6] "-" ECU

BO_ 512 ecuState: 4 ECU
 SG_ accelPedal :    0|8@1+ (2,0)   [0|100]   "%" TCU
 SG_ k15 :           8|1@1+ (1,0)   [0|1]     "-" TCU
 SG_ oilTemp :       9|9@1- (2,50)  [-50|150] "Grad C" TCU
 SG_ radiatorTemp : 18|9@1- (2,50)  [-50|150] "Grad C" TCU
...
----

The `modelDescription.xml` excerpt listed below shows which variables would exist for the `Powertrain.dbc` shown above.

.Example modelDescription.xml for ECU node
[#modelDescription.xml]
[source, XML]
----
include::examples/X_network4FMI_modelDescription.xml[]
----

The following file shows the `<Terminal>` definition representing the network and frame structure defined with `Powertrain.dbc` above.

.Example terminalsAndIcons.xml file
[#terminalsAndIcon.xml]
[source, XML]
----
include::examples/X_network4FMI_terminalsAndIcons.xml[]
----

=== Known Limitations of this Standard

This layered standard maps several network protocols onto co-simulation variables as transport layer simulating in many ways an ideal network.
Such an ideal network differs from physical networks in the following ways (and potentially others):

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules. +
   Here all frames are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network. +
   Here the network has infinite capacity.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function. +
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold. +
   Here the FMU will receive all frames, regardless of buffer size.

 * Network transmission errors: electrical errors which cause failed frame transmission. +
   Here no such transmission errors can occur, unless explicitly added into the simulation.

 * [[multiOutput]]Network protocols allow frames to be sent from more than one node. +
   Here this is also possible, with output variables for frames (and their signals) that are sent by more than one FMU.
   This requires the importer to handle the case when multiple source FMUs are sending the same frame.
   Importers must know how to handle this, just like they must know how to handle flow variables according to Kirchhoff's law.
